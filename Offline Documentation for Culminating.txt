Author - Ryan Bae and Aayush Dave

Class / Section - ICS 3U1

Date - January 14, 2018

Version - 7

Unit / Question # - Culminating Assignment 

Programming Language - Python 3.7.1 easygui

Problem Description - This game is an RPG fighting game where the user chooses a character to play as. This character has a certain amount of HP and three abilities. 
The abilities can either be attack based or defense based (the name should be a dead giveaway).The user gets to choose either single or multiplayer (up to two players
at a time) and then they must fight. The first character to lose all their HP, loses.Play modes include: A.I. (random or chosen by player) and single-player (vs. A.I.).

Program Assumptions - User must follow all prompts and they must also be able to run python, pillow and easygui on their device to allow.

Features of Program - User can select pictures, which gives it more a game feel rather than just selecting a word. Similarly, there is also a logo that was created for the menu itself. Our program also utilizes everything we've learned in classs such as: functions, lists, arrays, conditional statements, math (problem set 1) and parsing.

Restrictions - There are no animations for the fights itself, which is a limiting factor based on the module used (easygui). User cannot travel the world in a linear or  open-ended fashion in RPG's (this game is simply the fighting aspect of old RPG games like Pokemon. Similarly, pictures for each character do not show up on the screen  when the two characters are fighting, since easygui does not allow that (one picture can only be displayed and we couldn't find pictures for all the combinations).

Known Errors - By pressing the exit button in the top left corner (present in all windows), the program does not recognize this as a valid exit and it show the previous window (msg box) instead. If the button is clicked once more, the sudo code shows an error. Sometimes a different action occurs rather than showing the previous window, but the error always show up, unless you close the first window that shows up. 

Implementation Details / How to build the program - Before building the program, both easygui and python pillow were installed (images were not working due to an unknown error). Before starting the code, both additional modules were imported along with the random library. Our first function was the menu function or the start up screen with the option to start, get additional information or exit. We used button boxes to allow user to select which option they can choose. If they chose instructions, it would lead them to a message box telling them the instructions of the game. once they finish reading, they hit "Ok" and end up at the start menu. If user chooses exit, they leave the program. The next function is for the character choices. This function equates a character name to the image that was chosen, which will be beneficial for the move set and for the A.I.'s choice. The function returns the name. The next function is for the end of the game and is called the end menu function. Basically, it either allows the user to restart the game and go back to the main menu or exit, once they are defeated or defeat the A.I. The next function confirms the exit choice. If the user decides to either exit at the menu or the exit menu, this function is used to confirm whether the user wishes to leave. If the user hits yes, the program closes but, if they choose no, it sends them back to the main menu since 1 was returned. The next function is for the difficulty level. It gives the user three options: easy, medium or hard. Depending on the choice, the A.I. attacks do more damage. The choices are in the form of button boxes on the bottom of the window. The next function allows the user to choose the game type - whether they select the A.I. or whether it is random. The choices are in a button box on the bottom of the window. The function returns their choice. The next function is the player's move set. Based on the image chosen, there are a certain amount of moves. The function uses if and elif statements for the vast number of characters' moves. The function returns the player moves. The next function is for the mana (our in game currency). The function checks whether the amount of mana that the player has is enough to use the move. If they do, the function asks them to confirm the choice and if they don't, they must choose another move. If user has enough mana but wishes to use another move, the function send them back to the move set screen. The function returns the player's mana. The next function is for the A.I.'s character's moves. Based on either the random choice or the one that the user makes for them, the A.I. receives a set of moves which are chosen based on if and elif statements. The function returns their character choice. The next function is for the A.I.'s moves and mana. They A.I. randomly chooses its moves and so it may choose a move that requires more mana than the A.I. has. This function makes the A.I. choose a move again if the cost is higher than the amount of mana the A.I. has. If the A.I. has enough, it subtracts the cost from the total. The function returns the mana and the move chosen. The next function is the move interpreter function. This function also decides the turn for each character: A.I. is all even turns and the player is all odd turns (turn % 2 == 0 or turn % 2 !=0). Next it sets up all variables (attack, defence and factor) at 0 so nothing is added on by accident. The next part is many conditional statements that equate a certain value to a move. All moves are. Either attack or defence and most have a factor of 1. The factor is basically how long a move affects the other player (1 = 1 turn, 2 = 2 turns, etc.). Some have a factor of 1 and others have a factor of 2. After equating all of the moves to a value, the function then returns all these variables at the end. The next function is a health updater. This function is used after an attack and is used to update the health of the character as the name mould suggest. New variables are added in this function but, based on the turn, they equate to different values (i.e. the health when the turn is even is the A.I,'s health but it is the user's health when the turn is odd). Each if/ elif statement based on turn has 8 new variables (health, who's move it is, value of the move, previous move, enemy's health, enemy's defence and enemy's move) that are all used to find the new health. After the conditional statements, there are new variables that find the character attack, previous attack value, factor, enemy defend and enemy factor. Due to the 8 variables being different based on turn, only one set of equations is required to determine the new health of the player whose turn it is. The total attack calculates the character's attack and total defence calculates the enemy's defence. The net attack is the overall damage the other player takes in this turn. The next part is for specific conditions. If enemy uses Horcrux, the damage dealt is only 25% of the total attack. If the net attack is less than 0, it automatically becomes 0 as to not add to the enemy's HP. The next part is specific to the difficulty. If it easy, only 85% of the A.i.'s attack damages user. If it is medium, all 100% of the A.I.'s attack affects user. If it is hard, 115% of the attack affects user. Next, after all these conditions are met, the enemy health decreases based on the net attack. The next part decreases the factor by one since a turn was completed. Next, if anyone was using brackium emendo, their HP goes up by 50. Lastly, the old factor is deleted from the list and the new one is added in as to not cause any mishaps. The next two functions find the player's health and the A.I.'s health from the array (see below) and returns that value. The next two function is just to display a message to the user based on the amount of damage dealt, theirs/enemy's HP, the enemy's block. If brackium emendo or horcrux are user, a special message shows up. Now that all the functions are done, we begin the real code. The message right now is blank and the title is always "Crossover" since that it is the name of the game. The next part is a character list which has all the 9 images of our characters. The next part is an array for the move set for each character and the corresponding images. Next is the health array that equates the character to a specific amount of HP and the cost array that equates a move to a specific amount of mana. Next part is the main block of code for the game. It begins with a while loop, stating while menu(msg) == 1, this runs. Next is the choice of the amount of players. This allows the user to either exit the game if they forgot to at the menu or continue by choosing single player. Once chosen, the player chooses their difficulty and then the whether they choose the A.I. or if it is random. If it is a random, a random choice generator chooses from the character list. It then tells the user, which character was chosen. If user wishes to choose, they are shown the character list screen and choose a character. Next, the function for player health and A.I. health are called and run. Then, the values for mana for both characters is set at 0. The values for player defence and A.I. defence are set at 0. The player previous move array is set at [0,0,0] and the player move and A.I. move is blank for the time being since no move has been chosen. This also makes sure that there is no confusion for the second or third turn for the move chosen. The A.I.'s previous move and move value arrays are both set at [0,0,0] since no previous move has been made. Next is the actual start of the game. There is another while loop but it is an unconditional while loop (while True). The player mana, A.I. mana and turn are all increased (the first two by 100 and the last one by 1). This increases by this number after each turn. Next, the player move function and mana checker function are called upon and run. While the amount of mana coincides with the chosen move, the player move function and mana checker function continue running. If at any point the mana does not coincide with the value of the move, the message pops up telling user that they cannot use this move and are taken back to the move set choice. Next, the move interpreter function and the health updater function are called upon and run. Next, the. Program deciphers the values of the A.I. health, player health, both previous attack values and A.I.'s move's factor based on the return list from the health updater function. The next part is two conditional statements (separate from each other) based on: a) if the A.I.'s factor is less than or equal to 0, the previous move array for the A.I. is set at [0,0,0] and b) if the player's move is meant to last longer than one turn, the previous move becomes the player move. Next the player attack and player defence values are called upon and the player message. Is called upon and run. If the A.I. health reaches 0, that means the player wins and then unconditional while loop. (While True) is broken out of. If the A.I. is not dead, a turn is added and the next part runs the same functions as it did during the player's turn but instead runs the. Corresponding A.I. functions instead (player_mana_checker() function would be ai_mana_and_health() function). If, after this, the player's health is gone, the A.I. wins and the unconditional loop is broken. Outside of the second while loop (the unconditional while True loop), the end menu function is called upon and run with the while menu(msg) == 1 loop. If the user chooses to see the menu again, the menu runs instead the loop and the game repeats. If not, the user exits the program.


Additional Files - "vader_choke.gif","vader_lightsaber.gif","lightsaber_block.gif","yoda_block.gif","yoda_lightsaber.gif","lightsaber_block.gif","blaster.gif", "flamethrower.gif", "rpg.gif"
"hammer_throw.gif", "lightning_thor.gif", "hammer_block.gif", "PUNCH.gif", "SMASH.gif", "sonic_clap.gif", "roll_out.gif", "shield.gif", "truck_slam.gif", "need_for_speed.gif", "retreat.gif", "inferno.gif", "brackium_emendo.gif", "aquamenti.gif", "crucio.gif", "avada_kedavra.gif", "horcrux.gif", "Offline Documentation for Culimating.txt", python PIL and easygui